--#############
--# Paulo Trigo
--#############


--=============
-- Ligacao a BD
--=============
\set dataBase aug_real_db
;
\set userName postgres
;
\connect :dataBase :userName
;
--==========================
--==========================
-----------------------------------------
 -- Funções de Cinemática e Perseguição
----------------------------------------

CREATE OR REPLACE FUNCTION normalizar( vec t_vector )
RETURNS t_vector
AS $$
DECLARE
  norma real;
BEGIN
  norma := sqrt(power(vec.x, 2) + power(vec.y, 2));
  RETURN vec/norma;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION novo_posicao(posicao geometry, velocidade t_velocidade, tempo REAL)
RETURNS geometry AS $$
BEGIN

    RETURN ST_Translate(posicao, 
        mod((velocidade.linear).x * tempo, 100), 
        mod((velocidade.linear).y * tempo, 100);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION novo_orientacao(orientacao REAL, velocidade t_velocidade, tempo REAL)
RETURNS REAL AS $$
BEGIN
    RETURN orientacao + (velocidade.angular) * tempo;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION novo_velocidade(velocidade t_velocidade, aceleracao t_aceleracao, tempo real, max_vel_lin real, max_vel_ang real)
RETURNS t_velocidade AS $$
DECLARE
    nova_vel t_velocidade;
    vel_lin_mag REAL;
BEGIN
    nova_vel.linear := velocidade.linear + aceleracao.linear * tempo;
    nova_vel.angular := (velocidade.angular) + (aceleracao.angular) * tempo;

    -- Aplicar restrição de velocidade LINEAR
    vel_lin_mag := sqrt((nova_vel.linear).x^2 + (nova_vel.linear).y^2);
    IF vel_lin_mag > max_vel_lin THEN
        nova_vel.linear := (nova_vel.linear / vel_lin_mag) * max_vel_lin;
    END IF;

    -- Aplicar restrição de velocidade ANGULAR
    IF abs(nova_vel.angular) > max_vel_ang THEN
        nova_vel.angular := SIGN(nova_vel.angular) * max_vel_ang;
    END IF;

    RETURN nova_vel;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION obter_aceleracao_perseguidor(perseguidor_id INTEGER, alvo_id INTEGER, velocidade_a_perseguir REAL, max_aceleracao_angular REAL)
RETURNS t_aceleracao AS $$
DECLARE
    posicao_perseguidor geometry;
    posicao_alvo geometry;
    direcao t_vector;
    angulo_alvo REAL;
    angulo_perseguidor REAL;
    diferenca_angular REAL;
    aceleracao t_aceleracao;
BEGIN
    SELECT posicao INTO posicao_perseguidor FROM trajetoria WHERE objeto_id = perseguidor_id ORDER BY timestamp DESC LIMIT 1;
    SELECT posicao INTO posicao_alvo FROM trajetoria WHERE objeto_id = alvo_id ORDER BY timestamp DESC LIMIT 1;
    SELECT orientacao INTO angulo_perseguidor FROM objeto WHERE id_objeto = perseguidor_id;

    direcao := normalizar(ROW(ST_X(posicao_alvo) - ST_X(posicao_perseguidor), ST_Y(posicao_alvo) - ST_Y(posicao_perseguidor))::t_vector);
    aceleracao.linear := produto_vector_por_escalar(direcao, velocidade_a_perseguir);

    -- Calcular ângulo até o alvo (CORREÇÃO AQUI)
    angulo_alvo := degrees(atan2(ST_Y(posicao_alvo) - ST_Y(posicao_perseguidor), ST_X(posicao_alvo) - ST_X(posicao_perseguidor)));

    -- Calcular a diferença angular (considerando a direção atual do perseguidor)
    diferenca_angular := angulo_alvo - angulo_perseguidor;

    -- Ajustar a diferença angular para o intervalo [-180, 180]
    WHILE diferenca_angular > 180 LOOP
        diferenca_angular := diferenca_angular - 360;
    END LOOP;
    WHILE diferenca_angular < -180 LOOP
        diferenca_angular := diferenca_angular + 360;
    END LOOP;

    -- Converter a diferença angular para aceleração angular (limitada ao máximo)
    aceleracao.angular := LEAST(GREATEST(diferenca_angular, -max_aceleracao_angular), max_aceleracao_angular);

    RETURN aceleracao;
END;
$$ LANGUAGE plpgsql;



-- Função simular_passo (CORREÇÕES CRUCIAIS)
CREATE OR REPLACE FUNCTION simular_passo(perseguidor_id INTEGER, alvo_id INTEGER, tempo REAL)
RETURNS VOID AS $$
DECLARE
    objeto_atual RECORD;
    aceleracao_calculada t_aceleracao;
    tipo_objeto RECORD;
    nova_velocidade t_velocidade;
    nova_orientacao REAL;
    nova_posicao geometry;
    modificador_terreno REAL := 1.0;
    terreno RECORD;
    rio RECORD;
BEGIN
    SELECT velocidade, orientacao, centro_de_massa INTO objeto_atual
    FROM objeto
    WHERE id_objeto = perseguidor_id;

    IF NOT FOUND THEN
        RAISE NOTICE 'Objeto com ID % não encontrado!', perseguidor_id;
        RETURN;
    END IF;

    SELECT * INTO tipo_objeto FROM tipo_objeto WHERE id_tipo_objeto = (SELECT tipo_objeto_id FROM objeto WHERE id_objeto = perseguidor_id);

    -- Chamada ÚNICA e CORRETA a obter_aceleracao_perseguidor
    aceleracao_calculada := obter_aceleracao_perseguidor(perseguidor_id, alvo_id, tipo_objeto.max_aceleracao_linear, tipo_objeto.max_aceleracao_angular);

    nova_velocidade := novo_velocidade(objeto_atual.velocidade, aceleracao_calculada, tempo, tipo_objeto.max_velocidade_linear, tipo_objeto.max_velocidade_angular);
    nova_orientacao := novo_orientacao(objeto_atual.orientacao, nova_velocidade, tempo);

    -- Correção CRUCIAL: Usar o centro_de_massa *atual* SEMPRE.
    nova_posicao := objeto_atual.centro_de_massa;

    -- Aplicar modificador de terreno (ANTES do cálculo da nova posição)
    FOR terreno IN SELECT * FROM terreno WHERE ST_Contains(g_terreno, nova_posicao) LOOP
        SELECT percent_modif_tipo_terreno INTO modificador_terreno FROM tipo_terreno WHERE id_tipo_terreno = terreno.tipo_terreno_id;
        EXIT;
    END LOOP;

    FOR rio IN SELECT * FROM rio WHERE ST_Intersects(g_caudal, nova_posicao) LOOP
        modificador_terreno := modificador_terreno * rio.percent_modif_rio;
        EXIT;
    END LOOP;

    nova_velocidade.linear := produto_vector_por_escalar(nova_velocidade.linear, modificador_terreno);

    -- Calcular nova posição (com a velocidade modificada)
    nova_posicao := novo_posicao(nova_posicao, nova_velocidade, tempo);

    -- Detetar colisão
    IF ST_Intersects(nova_posicao, (SELECT centro_de_massa FROM objeto WHERE id_objeto = alvo_id)) THEN
        RAISE NOTICE 'COLISÃO DETETADA entre % e %!', perseguidor_id, alvo_id;
        -- Implementar lógica de colisão aqui (ex: definir velocidade para 0)
        nova_velocidade.linear.x := 0;
        nova_velocidade.linear.y := 0;
        nova_velocidade.angular := 0;
    END IF;

    -- Atualizar objeto com nova velocidade, orientação E CENTRO DE MASSA
    UPDATE objeto SET velocidade = nova_velocidade, orientacao = nova_orientacao, centro_de_massa = nova_posicao
    WHERE id_objeto = perseguidor_id;

    -- Inserir nova trajetória com timestamp
    INSERT INTO trajetoria (
        objeto_id, timestamp, posicao, orientacao,
        velocidade_linear, velocidade_angular,
        aceleracao_linear, aceleracao_angular
    ) VALUES (
        perseguidor_id, clock_timestamp(), nova_posicao, nova_orientacao,
        nova_velocidade.linear, nova_velocidade.angular,
        aceleracao_calculada.linear, aceleracao_calculada.angular
    );
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
    FOR i IN 1..20 LOOP
        PERFORM simular_passo(1, 2, 0.1);
        PERFORM simular_passo(3, 4, 0.1);
        PERFORM simular_passo(5, 6, 0.1);
    END LOOP;
END $$;

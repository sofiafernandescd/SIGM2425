CREATE EXTENSION postgis;


-----------------
-- Tipos de dados
-----------------
CREATE TYPE t_vector AS (
    x REAL,
    y REAL
);

CREATE TYPE t_velocidade AS (
    linear t_vector,
    angular REAL
);

CREATE TYPE t_aceleracao AS (
    linear t_vector,
    angular REAL
);


-----------------
-- Funções
-----------------
CREATE OR REPLACE FUNCTION produto_vector_por_escalar( vec t_vector, v real )
RETURNS t_vector
AS $$
DECLARE
    new_x real;
    new_y real;
BEGIN
    new_x := vec.x * v;
    new_y := vec.y * v;
    RETURN (new_x, new_y);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION soma_vector_vector( vec_a t_vector, vec_b t_vector )
RETURNS t_vector
AS $$
DECLARE
  new_x real;
  new_y real;
BEGIN
  new_x := vec_a.x + vec_b.x;
  new_y := vec_a.y + vec_b.y;
  RETURN (new_x, new_y);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION normalizar( vec t_vector )
RETURNS t_vector
AS $$
DECLARE
  norma real;
  new_x real;
  new_y real;
BEGIN
  norma := sqrt(power(vec.x, 2) + power(vec.y, 2));
  new_x := vec.x / norma;
  new_y := vec.y / norma;
  RETURN (new_x, new_y);
END;
$$ LANGUAGE plpgsql;

-----------------
-- Operadores
-----------------
CREATE OPERATOR * (
    leftarg = t_vector,
    rightarg = real,
    procedure = produto_vector_por_escalar,
    commutator = *
);

CREATE OPERATOR + (
    leftarg = t_vector,
    rightarg = t_vector,
    procedure = soma_vector_vector,
    commutator = +
);


------------------------
-- Funções de cinematica
------------------------

CREATE OR REPLACE FUNCTION novo_posicao(posicao geometry, velocidade t_velocidade, tempo REAL)
RETURNS geometry AS $$
BEGIN
    RETURN ST_Translate(posicao, (velocidade.linear).x * tempo, (velocidade.linear).y * tempo);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION novo_orientacao(orientacao REAL, velocidade t_velocidade, tempo REAL)
RETURNS REAL AS $$
BEGIN
    RETURN orientacao + (velocidade.angular) * tempo;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION novo_velocidade(velocidade t_velocidade, aceleracao t_aceleracao, tempo REAL)
RETURNS t_velocidade AS $$
DECLARE
    nova_vel t_velocidade;
BEGIN
    nova_vel.linear.x := (velocidade.linear).x + (aceleracao.linear).x * tempo; -- Correção AQUI
    nova_vel.linear.y := (velocidade.linear).y + (aceleracao.linear).y * tempo; -- Correção AQUI
    nova_vel.angular := (velocidade.angular) + (aceleracao.angular) * tempo; -- Correção AQUI
    RETURN nova_vel;
END;
$$ LANGUAGE plpgsql;


-- Funções de cinemática (revisadas)

/*CREATE OR REPLACE FUNCTION novo_velocidade(velocidade t_velocidade, aceleracao t_aceleracao, tempo real)
RETURNS t_velocidade AS $$
BEGIN
    RETURN ROW(
        soma_vector_vector(velocidade.linear, produto_vector_por_escalar(aceleracao.linear, tempo)),
        velocidade.angular + aceleracao.angular * tempo
    )::t_velocidade;
END;
$$ LANGUAGE plpgsql;*/


-- PERSEGUICAO

--______________________________________________________________________________________________
-- Obter a nova aceleracao linear do objecto para realizar uma perseguicao
-- Formulacao:
-- aceleracao = normalizar( g_posicao_alvo - g_posicao_perseguidor ) * velocidade_a_perseguir
--______________________________________________________________________________________________
CREATE OR REPLACE FUNCTION novo_aceleracao_linear( g_posicao_perseguidor geometry,
                                                   g_posicao_alvo geometry,
                                                   velocidade_a_perseguir real )
RETURNS t_vector
AS $$
SELECT  normalizar(((ST_X($2) - ST_X($1))::real, (ST_Y($2) - ST_Y($1))::real)) * $3 ;
--SELECT normalizar(ST_Distance($1, $2)) * $3;
$$ LANGUAGE sql;



CREATE TABLE tipo_terreno (
    id_tipo_terreno SERIAL PRIMARY KEY,
    nome_tipo_terreno VARCHAR(255) NOT NULL,
    percent_modif_tipo_terreno real NOT NULL 
);

CREATE TABLE terreno (
    id_terreno SERIAL PRIMARY KEY,
    nome_terreno VARCHAR(255) NOT NULL,
    tipo_terreno_id INTEGER REFERENCES tipo_terreno(id_tipo_terreno),
    g_terreno GEOMETRY(POLYGON, 3763) NOT NULL,
    area real --trigger
);

CREATE TABLE rio (
    id_rio SERIAL PRIMARY KEY,
    nome_rio VARCHAR(255) NOT NULL,
    percent_modif_rio real NOT NULL, 
    g_rio GEOMETRY(LINESTRING, 3763) NOT NULL, 
    largura real NOT NULL DEFAULT 1,
    g_caudal GEOMETRY(POLYGON, 3763) NOT NULL --trigger
);

CREATE TABLE tipo_objeto (
    id_tipo_objeto SERIAL PRIMARY KEY,
    nome VARCHAR(255) NOT NULL,
    max_velocidade_linear real NOT NULL,
    max_velocidade_angular real NOT NULL,
    max_aceleracao_linear real NOT NULL,
    max_aceleracao_angular real NOT NULL
);

CREATE TABLE objeto (
    id_objeto SERIAL PRIMARY KEY,
    tipo_objeto_id INTEGER REFERENCES tipo_objeto(id_tipo_objeto),
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    g_objeto GEOMETRY(GEOMETRY, 3763), --atualiza com trajetoria
    centro_de_massa GEOMETRY(POINT, 3763), --atualiza com g_objeto
    velocidade t_velocidade NOT NULL DEFAULT ROW((0,0), 0)::t_velocidade, -- ADICIONADO AQUI
    orientacao REAL NOT NULL DEFAULT 0 -- ADICIONADO AQUI

);

CREATE TABLE trajetoria (
    id_trajetoria SERIAL PRIMARY KEY,
    objeto_id INTEGER REFERENCES objeto(id_objeto),
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    posicao GEOMETRY(POINT, 3763) NOT NULL,
    orientacao real NOT NULL,
    velocidade_linear t_vector NOT NULL,
    velocidade_angular real NOT NULL,
    aceleracao_linear t_vector NOT NULL,
    aceleracao_angular real NOT NULL
);

CREATE TABLE perseguicao (
    id_perseguicao SERIAL PRIMARY KEY,
    perseguidor_id INTEGER REFERENCES objeto(id_objeto),
    alvo_id INTEGER REFERENCES objeto(id_objeto),
    distancia real
);

CREATE INDEX idx_terreno_geo ON terreno USING GIST (g_terreno); 
CREATE INDEX idx_rio_geo ON rio USING GIST (g_rio);      
CREATE INDEX idx_objeto_centro_de_massa ON objeto USING GIST (centro_de_massa); 
CREATE INDEX idx_trajetoria_posicao ON trajetoria USING GIST (posicao);

-- TRIGGERS
CREATE OR REPLACE FUNCTION calcular_area_terreno()
RETURNS TRIGGER AS $$
BEGIN
    NEW.area = ST_Area(NEW.g_terreno);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_calcular_area_terreno
BEFORE INSERT OR UPDATE ON terreno
FOR EACH ROW EXECUTE PROCEDURE calcular_area_terreno();

-- Função para calcular o g_caudal
CREATE OR REPLACE FUNCTION calcular_g_caudal()
RETURNS TRIGGER AS $$
BEGIN
    NEW.g_caudal = ST_Buffer(NEW.g_rio, NEW.largura / 2.0, 'endcap=butt'); -- Usando 'endcap=butt'
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_calcular_g_caudal
BEFORE INSERT OR UPDATE OF g_rio, largura ON rio
FOR EACH ROW EXECUTE PROCEDURE calcular_g_caudal();

CREATE OR REPLACE FUNCTION calcular_centro_de_massa()
RETURNS TRIGGER AS $$
BEGIN
    NEW.centro_de_massa = ST_Centroid(NEW.g_objeto); -- Corrigido nome da coluna
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_calcular_centro_de_massa
BEFORE INSERT OR UPDATE OF g_objeto ON objeto -- Corrigido nome da coluna
FOR EACH ROW EXECUTE PROCEDURE calcular_centro_de_massa();

-- Inserir tipos de terreno (mantido)
INSERT INTO tipo_terreno (nome_tipo_terreno, percent_modif_tipo_terreno) VALUES
('Asfalto', 1.0),
('Relva', 0.8),
('Terra Batida', 0.9),
('Água', 0.5),
('Floresta Densa', 0.6);

-- Inserir terrenos com nomes mais descritivos e variados
INSERT INTO terreno (nome_terreno, tipo_terreno_id, g_terreno) VALUES
('Praça Central', 1, ST_GeomFromText('POLYGON((0 0, 30 0, 30 30, 0 30, 0 0))', 3763)), -- Grande área aberta (Asfalto)
('Bosque Norte', 5, ST_GeomFromText('POLYGON((35 10, 50 10, 50 25, 35 25, 35 10))', 3763)), -- Área com vegetação densa (Floresta Densa)
('Campo de Relva', 2, ST_GeomFromText('POLYGON((0 35, 20 35, 20 50, 0 50, 0 35))', 3763)), -- Área de relva
('Lago Sul', 4, ST_GeomFromText('POLYGON((25 35, 45 35, 45 50, 25 50, 25 35))', 3763)), -- Área com água
('Estrada Principal', 1, ST_GeomFromText('POLYGON((10 10, 20 10, 20 12, 10 12, 10 10))', 3763));--Estrada dentro da Praça Central

-- Inserir rios (com nomes)
INSERT INTO rio (nome_rio, percent_modif_rio, g_rio, largura) VALUES
('Rio Douro', 0.5, ST_GeomFromText('LINESTRING(5 40, 15 40)', 3763), 3), -- Atravessa o Campo de Relva
('Ribeiro Norte', 0.7, ST_GeomFromText('LINESTRING(40 15, 40 20)', 3763), 1); -- Atravessa o Bosque Norte

-- Inserir tipos de objeto (mantido)
INSERT INTO tipo_objeto (nome, max_velocidade_linear, max_velocidade_angular, max_aceleracao_linear, max_aceleracao_angular) VALUES
('Carro', 10, 2, 5, 1),
('Barco', 5, 1, 2, 0.5),
('Drone', 15, 3, 7, 1.5),
('Jipe', 8, 1.5, 4, 0.8); -- Novo tipo de objeto

-- Inserir objetos para 3 perseguições distintas
INSERT INTO objeto (tipo_objeto_id, g_objeto) VALUES
(1, ST_GeomFromText('POINT(2 2)', 3763)),   -- Perseguidor 1: Carro na Praça Central
(3, ST_GeomFromText('POINT(28 28)', 3763)), -- Alvo 1: Drone na Praça Central (perseguição 1)
(4, ST_GeomFromText('POINT(37 12)', 3763)), -- Perseguidor 2: Jipe no Bosque Norte
(1, ST_GeomFromText('POINT(48 22)', 3763)), -- Alvo 2: Carro no Bosque Norte (perseguição 2)
(2, ST_GeomFromText('POINT(3 42)', 3763)),   -- Perseguidor 3: Barco no Campo de Relva (perto do rio)
(3, ST_GeomFromText('POINT(18 42)', 3763)); -- Alvo 3: Drone no Campo de Relva (perseguição 3)

-- Inserir dados iniciais na tabela trajetoria para todos os objetos
INSERT INTO trajetoria (objeto_id, posicao, orientacao, velocidade_linear, velocidade_angular, aceleracao_linear, aceleracao_angular) VALUES
(1, ST_GeomFromText('POINT(2 2)', 3763), 0, ROW(0.0, 0.0)::t_vector, 0, ROW(0.0, 0.0)::t_vector, 0), -- Perseguidor 1
(2, ST_GeomFromText('POINT(28 28)', 3763), 0, ROW(0.0, 0.0)::t_vector, 0, ROW(0.0, 0.0)::t_vector, 0), -- Alvo 1
(3, ST_GeomFromText('POINT(37 12)', 3763), 0, ROW(0.0, 0.0)::t_vector, 0, ROW(0.0, 0.0)::t_vector, 0), -- Perseguidor 2
(4, ST_GeomFromText('POINT(48 22)', 3763), 0, ROW(0.0, 0.0)::t_vector, 0, ROW(0.0, 0.0)::t_vector, 0), -- Alvo 2
(5, ST_GeomFromText('POINT(3 42)', 3763), 0, ROW(0.0, 0.0)::t_vector, 0, ROW(0.0, 0.0)::t_vector, 0), -- Perseguidor 3
(6, ST_GeomFromText('POINT(18 42)', 3763), 0, ROW(0.0, 0.0)::t_vector, 0, ROW(0.0, 0.0)::t_vector, 0); -- Alvo 3

-- Inserir as 3 perseguições
INSERT INTO perseguicao (perseguidor_id, alvo_id, distancia) VALUES
(1, 2, ST_Distance( (SELECT posicao from trajetoria where objeto_id = 1 order by timestamp desc limit 1), (SELECT posicao from trajetoria where objeto_id = 2 order by timestamp desc limit 1) )), -- Perseguição 1
(3, 4, ST_Distance( (SELECT posicao from trajetoria where objeto_id = 3 order by timestamp desc limit 1), (SELECT posicao from trajetoria where objeto_id = 4 order by timestamp desc limit 1) )), -- Perseguição 2
(5, 6, ST_Distance( (SELECT posicao from trajetoria where objeto_id = 5 order by timestamp desc limit 1), (SELECT posicao from trajetoria where objeto_id = 6 order by timestamp desc limit 1) )); -- Perseguição 3



 ------------------------
-- Funções de cinemática (CORRIGIDAS)
------------------------
CREATE OR REPLACE FUNCTION novo_posicao(posicao geometry, velocidade t_velocidade, tempo REAL)
RETURNS geometry AS $$
BEGIN
    RETURN ST_Translate(posicao, (velocidade.linear).x * tempo, (velocidade.linear).y * tempo);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION novo_orientacao(orientacao REAL, velocidade t_velocidade, tempo REAL)
RETURNS REAL AS $$
BEGIN
    RETURN orientacao + (velocidade.angular) * tempo;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION novo_velocidade(velocidade t_velocidade, aceleracao t_aceleracao, tempo REAL)
RETURNS t_velocidade AS $$
DECLARE
    nova_vel t_velocidade;
BEGIN
    nova_vel.linear.x := (velocidade.linear).x + (aceleracao.linear).x * tempo; -- Correção AQUI
    nova_vel.linear.y := (velocidade.linear).y + (aceleracao.linear).y * tempo; -- Correção AQUI
    nova_vel.angular := (velocidade.angular) + (aceleracao.angular) * tempo; -- Correção AQUI
    RETURN nova_vel;
END;
$$ LANGUAGE plpgsql;

-- Funções de Perseguição
------------------------
CREATE OR REPLACE FUNCTION obter_aceleracao_perseguidor(perseguidor_id INTEGER, alvo_id INTEGER, velocidade_a_perseguir REAL)
RETURNS t_aceleracao AS $$
DECLARE
    posicao_perseguidor geometry;
    posicao_alvo geometry;
    direcao t_vector;
    aceleracao t_aceleracao;
BEGIN
    SELECT posicao INTO posicao_perseguidor FROM trajetoria WHERE objeto_id = perseguidor_id ORDER BY timestamp DESC LIMIT 1;
    SELECT posicao INTO posicao_alvo FROM trajetoria WHERE objeto_id = alvo_id ORDER BY timestamp DESC LIMIT 1;

    direcao := normalizar(ROW(ST_X(posicao_alvo) - ST_X(posicao_perseguidor), ST_Y(posicao_alvo) - ST_Y(posicao_perseguidor))::t_vector);
    aceleracao.linear := produto_vector_por_escalar(direcao, velocidade_a_perseguir);
    aceleracao.angular := 0; -- Por enquanto, aceleração angular zero (pode ser implementada depois)
    RETURN aceleracao;
END;
$$ LANGUAGE plpgsql;



-- Função de Simulação (COMPLETAMENTE CORRIGIDA)
CREATE OR REPLACE FUNCTION simular_passo(perseguidor_id INTEGER, alvo_id INTEGER, tempo REAL)
RETURNS VOID AS $$
DECLARE
    objeto_atual RECORD;
    aceleracao_calculada t_aceleracao;
    tipo_objeto RECORD;
    nova_velocidade t_velocidade;
    nova_orientacao REAL;
    nova_posicao geometry;
    modificador_terreno REAL := 1.0;
    terreno RECORD;
    rio RECORD;
BEGIN
    SELECT velocidade, orientacao, centro_de_massa INTO objeto_atual
    FROM objeto
    WHERE id_objeto = perseguidor_id;

    IF NOT FOUND THEN
        RAISE NOTICE 'Objeto com ID % não encontrado!', perseguidor_id;
        RETURN;
    END IF;

    SELECT * INTO tipo_objeto FROM tipo_objeto WHERE id_tipo_objeto = (SELECT tipo_objeto_id FROM objeto WHERE id_objeto = perseguidor_id);

    aceleracao_calculada := obter_aceleracao_perseguidor(perseguidor_id, alvo_id, tipo_objeto.max_aceleracao_linear);

    nova_velocidade := novo_velocidade(objeto_atual.velocidade, aceleracao_calculada, tempo);
    nova_orientacao := novo_orientacao(objeto_atual.orientacao, nova_velocidade, tempo);

    -- Correção CRUCIAL: Usar o centro_de_massa *atual* SEMPRE.
    nova_posicao := objeto_atual.centro_de_massa;

    -- Aplicar modificador de terreno (ANTES do cálculo da nova posição)
    FOR terreno IN SELECT * FROM terreno WHERE ST_Contains(g_terreno, nova_posicao) LOOP
        SELECT percent_modif_tipo_terreno INTO modificador_terreno FROM tipo_terreno WHERE id_tipo_terreno = terreno.tipo_terreno_id;
        EXIT;
    END LOOP;

    FOR rio IN SELECT * FROM rio WHERE ST_Intersects(g_caudal, nova_posicao) LOOP
        modificador_terreno := modificador_terreno * rio.percent_modif_rio;
        EXIT;
    END LOOP;

    nova_velocidade.linear := produto_vector_por_escalar(nova_velocidade.linear, modificador_terreno);

    -- Calcular nova posição (USANDO a velocidade modificada)
    nova_posicao := novo_posicao(nova_posicao, nova_velocidade, tempo);

    -- Atualizar objeto com nova velocidade, orientação E CENTRO DE MASSA
    UPDATE objeto SET velocidade = nova_velocidade, orientacao = nova_orientacao, centro_de_massa = nova_posicao
    WHERE id_objeto = perseguidor_id;

    -- Inserir nova trajetória com timestamp
    INSERT INTO trajetoria (
        objeto_id, timestamp, posicao, orientacao,
        velocidade_linear, velocidade_angular,
        aceleracao_linear, aceleracao_angular
    ) VALUES (
        perseguidor_id, clock_timestamp(), nova_posicao, nova_orientacao,
        nova_velocidade.linear, nova_velocidade.angular,
        aceleracao_calculada.linear, aceleracao_calculada.angular
    );
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
    FOR i IN 1..20 LOOP
        PERFORM simular_passo(1, 2, 0.1);
        PERFORM simular_passo(3, 4, 0.1);
        PERFORM simular_passo(5, 6, 0.1);
    END LOOP;
END $$;





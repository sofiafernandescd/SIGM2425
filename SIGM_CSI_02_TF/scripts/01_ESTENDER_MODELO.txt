--########################################################
--# Grupo 2, baseado nos exemplos do Professor Paulo Trigo
--########################################################

--=============
-- Ligacao a BD
--=============
\set dataBase aug_real_db
;
\set userName postgres
;
\connect :dataBase :userName
;
--==========================
--==========================
DROP OPERATOR IF EXISTS / (t_vector, real);
DROP OPERATOR IF EXISTS * (t_vector, real);
DROP OPERATOR IF EXISTS - (t_vector, t_vector);
DROP OPERATOR IF EXISTS + (t_vector, t_vector);

DROP FUNCTION IF EXISTS divisao_vector_por_escalar(t_vector, real);
DROP FUNCTION IF EXISTS produto_vector_por_escalar(t_vector, real);
DROP FUNCTION IF EXISTS subtracao_vector_vector(t_vector, t_vector);
DROP FUNCTION IF EXISTS soma_vector_vector(t_vector, t_vector);

DROP TYPE IF EXISTS t_aceleracao;
DROP TYPE IF EXISTS t_velocidade;
DROP TYPE IF EXISTS t_vector;

----------------------------------------------------
----------------------------------------------------
-- Estender o Modelo Relacional com Novas Estruturas
----------------------------------------------------
----------------------------------------------------

-----------------
-- Tipos de dados
-----------------
CREATE TYPE t_vector AS (
    x REAL,
    y REAL
);

CREATE TYPE t_velocidade AS (
    linear t_vector,
    angular REAL
);

CREATE TYPE t_aceleracao AS (
    linear t_vector,
    angular REAL
);

-------------------------------------------------
-- Funções auxiliares para operadores com vetores
-------------------------------------------------

CREATE OR REPLACE FUNCTION soma_vector_vector( vec_a t_vector, vec_b t_vector )
RETURNS t_vector
AS $$
DECLARE
  new_x real;
  new_y real;
BEGIN
  new_x := vec_a.x + vec_b.x;
  new_y := vec_a.y + vec_b.y;
  RETURN (new_x, new_y);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION subtracao_vector_vector( vec_a t_vector, vec_b t_vector )
RETURNS t_vector
AS $$
DECLARE
  new_x real;
  new_y real;
BEGIN
  new_x := vec_a.x - vec_b.x;
  new_y := vec_a.y - vec_b.y;
  RETURN (new_x, new_y);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION produto_vector_por_escalar( vec t_vector, v real )
RETURNS t_vector
AS $$
DECLARE
    new_x real;
    new_y real;
BEGIN
    new_x := vec.x * v;
    new_y := vec.y * v;
    RETURN (new_x, new_y);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION divisao_vector_por_escalar(vec t_vector, v real)
RETURNS t_vector
AS $$
DECLARE
    new_x real;
    new_y real;
BEGIN
    IF v = 0 THEN
        -- Retornar um vetor nulo ou lançar um erro, dependendo do que é apropriado
        RAISE EXCEPTION 'Divisão por zero não é permitida no divisor escalar.';
    ELSE
        new_x := vec.x / v;
        new_y := vec.y / v;
    END IF;

    RETURN (new_x, new_y);
END;
$$ LANGUAGE plpgsql;

-----------------
-- Operadores 
-----------------
CREATE OPERATOR + (
    leftarg = t_vector,
    rightarg = t_vector,
    procedure = soma_vector_vector,
    commutator = +
);

CREATE OPERATOR - (
    leftarg = t_vector,
    rightarg = t_vector,
    procedure = subtracao_vector_vector,
    commutator = -
);

CREATE OPERATOR * (
    leftarg = t_vector,
    rightarg = real,
    procedure = produto_vector_por_escalar,
    commutator = *
);

CREATE OPERATOR / (
    leftarg = t_vector,
    rightarg = real,
    procedure = divisao_vector_por_escalar,
    commutator = /
);

